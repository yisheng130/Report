setwd("C:/Users/USER/Desktop/機器學習")

###LIBRARY####
library(dplyr)
library(tidyverse)

###DATA_PREPARE####
anime <- read.csv("C:/Users/USER/Desktop/機器學習/anime.csv", fileEncoding = "UTF-8")
rating <- read.csv("C:/Users/USER/Desktop/機器學習/rating.csv", fileEncoding = "UTF-8") 

#rating
#去除看過未評分
ratings_clean <- rating %>% filter(rating != -1)

#評分超過50次
active_users <- ratings_clean %>% count(user_id) %>% filter(n >= 50)
ratings_clean <- ratings_clean %>% filter(user_id %in% active_users$user_id)

#Random rating
set.seed(9453)
id <- names(table(ratings_clean$user_id))
sam_n <- sample(id, 350)

ratings_data <- ratings_clean[ratings_clean$user_id %in% sam_n,]


write.csv(ratings_data, "rating_data.csv", row.names = FALSE)


#anime
anime_clean <- anime[anime$anime_id  %in% ratings_data$anime_id,] 

anime_data <- anime_clean %>%  filter(!is.na(rating)) %>% filter(!genre == "") %>% 
  select(-c(episodes,members)) %>%  separate_rows(genre, sep = ", ") %>% 
  distinct(anime_id, genre, .keep_all = TRUE) %>%  mutate(value = 1) %>% 
  pivot_wider(names_from = genre, values_from = value, values_fill = 0)

write.csv(anime_data,"anime_data.csv", row.names = FALSE)

###DATA####
ratings_data <- read.csv("rating_data.csv")
anime_data <- read.csv("anime_data.csv")

###分析####
#PCA
pca <- prcomp(anime_data[,-(1:4)], scale = TRUE)
reduced_data <- pca$x[, 1:10] 

#K-means
kmeans_result <- kmeans(reduced_data, centers = 5)
anime_data$cluster <- kmeans_result$cluster

#相似度
recommendation <- function(target_name) {
  # 1. 找 A
  target_idx <- which(anime_data$name == target_name)
  if(length(target_idx) == 0) return(NULL)
  
  target_vector <- reduced_data[target_idx, ] # 這次是用 PC1...PC10
  target_cluster <- anime_data$cluster[target_idx]
  
  # 2. 找同群的 B
  cluster_indices <- which(anime_data$cluster == target_cluster)
  cluster_matrix <- reduced_data[cluster_indices, ]
  
  # 3. 算距離 (Euclidean)
  dists <- apply(cluster_matrix, 1, function(x) sqrt(sum((x - target_vector)^2)))
  
  # 4. 排序
  result <- anime_data[cluster_indices, ]
  result$distance <- dists
  result <- result[order(result$distance), ]
  result <- result[result$name != target_name, ]
  
  return(head(result[, c("name", "rating", "cluster")], 1))
}

# 測試預測
target_anime <- "Sword Art Online" # 建議用這部驗證，數據較多
predicted_anime <- recommendation(target_anime)

cat(sprintf("【PCA 版本預測結果】\n因為你喜歡 [%s] (Cluster %d)...\n", target_anime, anime_data$cluster[anime_data$name == target_anime]))
cat(sprintf("系統預測你會喜歡 B: [%s]\n", predicted_anime$name))



#rating驗證
check_accuracy <- function(anime_A, anime_B) {
  id_A <- anime_data$anime_id[anime_data$name == anime_A]
  id_B <- anime_data$anime_id[anime_data$name == anime_B]
  
  users_like_A <- ratings_data$user_id[ratings_data$anime_id == id_A & ratings_data$rating >= 7]
  users_watched_B <- ratings_data[ratings_data$user_id %in% users_like_A & ratings_data$anime_id == id_B, ]
  users_like_B <- users_watched_B[users_watched_B$rating >= 7, ]
  
  if(nrow(users_watched_B) == 0) return("資料不足")
  return(nrow(users_like_B) / nrow(users_watched_B))
}

# 執行驗證
accuracy <- check_accuracy(target_anime, predicted_anime$name)

if(is.numeric(accuracy)) {
  cat(sprintf("\n驗證準確率: %.2f%%\n", accuracy * 100))
} else {
  cat("\n", accuracy)
}


# 評分預測模型 
predict_my_rating <- function(anime_A_name, anime_B_name, my_rating_for_A) {
  
  # --- 1. 資料準備 (Data Preparation) ---
  id_A <- anime_data$anime_id[anime_data$name == anime_A_name]
  id_B <- anime_data$anime_id[anime_data$name == anime_B_name]
  
  # 找出看過 A 的人 & 找出看過 B 的人
  users_A <- ratings_data[ratings_data$anime_id == id_A, c("user_id", "rating")]
  users_B <- ratings_data[ratings_data$anime_id == id_B, c("user_id", "rating")]
  
  # 合併資料：找出「同時看過這兩部」的人 (這是我們的訓練資料)
  # 欄位變成: user_id, rating_A, rating_B
  train_df <- merge(users_A, users_B, by = "user_id", suffixes = c("_A", "_B"))
  
  # 檢查資料量
  if(nrow(train_df) < 10) {
    return(paste("資料不足：同時看過這兩部的人太少 (", nrow(train_df), "人)，無法訓練模型。", sep=""))
  }
  
  # --- 2. 拆分訓練集與測試集 (Train/Test Split) ---
  # 80% 用來學 (Training)，20% 用來考 (Testing)
  set.seed(123) # 固定隨機亂數，讓結果可重現
  sample_index <- sample(1:nrow(train_df), 0.7 * nrow(train_df))
  train_set <- train_df[sample_index, ]
  test_set  <- train_df[-sample_index, ]
  
  # --- 3. 訓練模型 (Training) ---
  model <- randomForest(rating_B ~ rating_A, data = train_set, ntree=100)
  
  # --- 4. 驗證模型 (Testing / Evaluation) ---
  # 讓電腦預測測試集的分數，並跟真實分數比對
  predictions <- predict(model, test_set)
  actuals <- test_set$rating_B
  
  # 計算誤差 (RMSE: 均方根誤差) - 平均預測差了幾分
  rmse <- sqrt(mean((predictions - actuals)^2))
  
  # --- 5. 實際預測 (Inference) ---
  # 預測「你」的分數：假設你給 A 打了 my_rating_for_A 分
  new_data <- data.frame(rating_A = my_rating_for_A)
  my_predicted_score <- predict(model, new_data)
  
  # 限制分數在 1-10 分之間 (修正超過範圍的預測)
  my_predicted_score <- min(max(my_predicted_score, 1), 10)
  
  # --- 輸出報告 ---
  cat(sprintf("\n=== 機器學習評分預測模型 ===\n"))
  cat(sprintf("模型誤差 (RMSE): %.2f 分 (平均誤差範圍)\n", rmse))
  cat(sprintf("相關係數: %.2f (兩部作品喜好連動程度)\n", cor(train_df$rating_A, train_df$rating_B)))
  cat(sprintf("------------------------------------\n"))
  cat(sprintf("【預測結果】\n"))
  cat(sprintf("如果你給 [%s] 打 %d 分...\n", anime_A_name, my_rating_for_A))
  cat(sprintf("系統預測你會給 [%s] : %.1f 分！\n", anime_B_name, my_predicted_score))
  
  return(my_predicted_score)
}

# --- 執行預測 ---
# 假設你給 "Sword Art Online" 打了 9 分，想知道你會給推薦作品打幾分
# 注意：這裡的 predicted_anime 是你上一段程式碼跑出來的結果
if(exists("predicted_anime")) {
  predict_my_rating(target_anime, predicted_anime$name, my_rating_for_A = 9)
}


